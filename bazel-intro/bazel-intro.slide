When "go build" isn't enough: Introduction to Bazel
June 1, 2023

Eugene Khabarov
PowerFly Consulting
Ottawa, ON, Canada

https://ekhabarov.com/talks

* Who am I
- Golang consultant
- Build APIs for fun and PROFIT!
- Focused on Developers' productivity and Team velocity in general.

* What we're going to build?
- Go binaries
- Docker images
- Kubernetes manifests.

* When "go build" is enough?
- When we already have *all* of the source files in place, i.e., we can run "go
  build" *only* and produce a *binary*.
- When a project doesn't require specific versions of dependencies*.

* When "go build" is not enough?
When we have to generate code *before* the build:

- *gRPC/protobuf*: *.proto => *.go
- *go*generate*:  any => *.go
- *go_bindata*: any => *.go
- *ffjson*: *.go => *.go
- *ragel*: *.rl => *.go
- etc.

Other requirements:

- Build reproducibility.
- Build isolation (Hello Docker!).
- Build restarts in case of failure (Hello Make!).
- Docker/Kubernetes

* How we define a dependency?
- Go packages: go.mod/go.sum
- Go compiler
- Generators
- Environment
- Bazelisk (.bazelversion)

* Tools involved into build process
- Golang
- protoc
- protoc-gen-go
- Docker
- Ytt/Kustomize/Helm
- Make
- _Python_

* Do you like games?

.image img/wl2.png 300 300

* Once I've seen this...

*.yaml + Jinja template => *Python* => *.proto => *protoc* => *.pb.go => *Go* => binary

* What we're going to solve?
To automate multi-step build process:

- Automatically install all external dependencies during the build.
- Generate and build everything with one-two commands.
- Pin all dependencies' versions: Go, Go packages, generators.
- Build all inside isolated environment.

* Hello Bazel!

* What is Bazel?
- An open-source build and tests tool
- Similar to Make, Ant, Gradle, Buck, Pants and Maven
- Invented at Google (open-sourced in 2015), aimed to build huge *monorepo*


Bazel shines at building and testing projects with the following properties:

- Projects with a large codebase
- Projects written in (multiple) compiled languages
- Projects that deploy on multiple platforms
- Projects that have extensive tests

.link https://bazel.build/about/faq

* Build
- Parallel build: Bazel uses as many cores as it found*.
.image img/cores.png
- Build can be run on a local or remote machine.
- Builds everything from sources including dependencies.
- Re-builds changed parts only.

* Cache
- Bazel caches all downloaded dependencies.
- Bazel caches intermediate build results.
- Cache shared between workspaces.
- Cache can be resided on a remote machine and shared between teams.

* A couple of concepts...

* Hermeticity
When given the same input source code and product configuration, a hermetic
build system always returns the same output by isolating the build from changes
to the host system.

*Isolation*: Hermetic build systems treat tools as source code.

*Source*identity*: Hermetic build systems try to ensure the sameness of inputs.

.link https://bazel.build/basics/hermeticity

* Sandboxing
Is a permission restricting strategy that isolates processes from each other or
from resources in a system. For Bazel, this means restricting file system
access.

Bazel's file system sandbox runs processes in a working directory that only
contains known inputs, such that compilers and other tools don't see source
files they should not access, unless they know the absolute paths to them.

.link https://bazel.build/docs/sandboxing

* What else?

* Bazel query
Some questions that query answers:

- What packages use package _X_?
- What packages exist beneath _foo_?
- What files are generated by rules in the _foo_ package?
- What's the set of BUILD files needed to build _//foo_?
- What rule target(s) contain file _path/to/file.go_ as a source?

.link https://docs.bazel.build/versions/main/query-how-to.html Bazel Query How-To

* Dependency graph

.image img/graph.png 400 500

.code samples/vis

* Extensibility
- rules_go
- rules_proto
- rules_docker
- rules_k8s
- rules_oci
- rules_dart
- rules_erlang
- rules_haskell
- rules_kotlin
- etc.

.link https://awesomebazel.com

* It's demo time!
.image img/shutup.jpg

* Hello world generator
- go build -o *generator* hello-world-generator/main.go
- ./generator > generated.go
- go build -o *hello-world* generated.go
- ./hello-world

.link https://github.com/ekhabarov/helloworld-generator

* Hello world generator (main.go)
.code samples/hello-world.go

* Hello world generator
.code samples/hello-world

* and with Bazel...

* Hello world generator: Bazelified
.code samples/hw-bazel-tree
There is no Go files here.

- *WORKSPACE* file: defines a project root and may contain external dependencies.
- *BUILD* file: defines a package. Declares build rules for the package.

.link https://github.com/ekhabarov/blog-code-snippets/tree/master/how-to-bazel/genereate-and-compile-go-code Github Repo
.link https://ekhabarov.com/post/how-to-generate-code-with-bazel/ Blog post

* Hello world generator: Bazelified (cont.)
WORKSPACE
.code samples/hw-bazel-workspace

* Hello world generator: Bazelified (cont.)
go_deps.bzl
.code samples/hw-bazel-deps
.link https://github.com/ekhabarov/helloworld-generator

* Hello world generator: Bazelified (cont.)
go/BUILD
.code samples/hw-bazel-build

* Hello world generator: Bazelified (cont.)
.code samples/hw-bazel-run
.code samples/hw-bazel-run-tree

* Glossary
- *Rule*: A function implementation that *registers* a series of actions.
- *Action*: A command to run during the build, for example, a call to a compiler
  that takes artifacts as *inputs* and produces other artifacts as *outputs*.
- *Target*: A buildable unit. Most targets are one of two principal kinds, files and rules.
- *Label*: A unique name for a target.

.link https://docs.bazel.build/versions/main/glossary.html#rule Full version

* Glossary (cont.)
go/BUILD

.code samples/hw-BUILD /^go_library/,/^\)

- Rule: _go__library_
- Action: takes a _hello.go_ and produces _hello-world.a_
- Target: _hello-world__lib_
- Label: _//go:hello-world__lib_

* Labels

.code samples/labels

* Demo: microservices & k8s
.image img/plan.png 350 700
- build two gRPC services
- build Docker images for the services, and for Evnoy proxy
- deploy all into local k8s cluster (minikube)
.link https://ekhabarov.com/envoy

* Should we write BUILD files manually?

* Gazelle
- Generates BUILD files
- Keeps it up to date
- Formats BUILD files
- Manages dependencies
- Works in ~95% of cases

* Conclusion
- Takes a time to learn: ecosystem, rules, etc.
- "go build" cannot be used directly.
- go.mod + go_deps.bzl
- Poor IDE/editors integration (broken autocomplete): work in progress.

*
.image img/colombo.png 500 800

* Bazel is not perfect, but it solves particular issues.
